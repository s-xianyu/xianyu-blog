[{"id":"086310466f06cd58819e76a548edff66","title":"JS设计模式之单列模式","content":"什么是单例模式单例模式：是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式单例模式是一种创建型设计模式，它确保一个类只有一个实例，并提供了一个全局访问点来访问该实例，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象说明：\n\n单例模式只有一个实例对象\n单例类必须自己创建自己的唯一实例\n单例类必须给所有其他对象提供这一实例\n一个全局使用的类频繁地创建与销毁\n饿汉式和懒汉式\n\n优缺点、和使用场景优点：\n\n在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例\n避免对资源的多重占用\n\n缺点：\n\n没有接口，不能继承，与单一职责原则冲突\n\n使用场景：\n\n网站计数器\n图片查看器\n全局提示\n\n\nJavaScript单例模式实现123456789101112131415const Toast = (() =&gt; &#123;    function ToastFun () &#123;      console.log(&#x27;提示&#x27;)    &#125;    let instance;    return function () &#123;      if (!instance) &#123;        instance = new ToastFun()      &#125;      return instance    &#125;;  &#125;)(); const test = () =&gt; &#123;   Toast() &#125;\nVue实现Toast轻提示\n创建toast.vue组件实现请提示弹框代码\n12345678910111213141516171819202122232425262728293031&lt;template&gt;  &lt;span class=&quot;box&quot; v-if=&quot;visible&quot;&gt;    &lt;img width=&quot;20&quot; :src=&quot;img&quot; alt=&quot;&quot;&gt;&lt;span&gt;&#123;&#123; text &#125;&#125;&lt;/span&gt;  &lt;/span&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data () &#123;    return &#123;      visible: false,      text: &#x27;&#x27;,      img: &#x27;https://schbrain-static-online.schbrain.com/resources/c82689d4fb6c9d8cb93b092dfed9bd70.png&#x27;    &#125;  &#125;&#125;&lt;/script&gt;&lt;style scoped lang=&quot;less&quot;&gt;.box &#123;  padding: 10px 15px;  background: rgba(0,0,0,.5);  border-radius: 4px;  position: absolute;  top: 50%;  left: 50%;  transform: translate(-50%, -50%);  color: #fff;&#125;&lt;/style&gt;\n\n创建toast.ts 创建单例组件\n123456789101112131415161718192021222324252627import &#123;createApp&#125; from &#x27;vue&#x27;import Toast from &#x27;./toast.vue&#x27;const ToastConstructor = createApp(Toast)let instance: any = nullconst ToastFn = (options: any) =&gt; &#123;  if (!instance) &#123;    instance = ToastConstructor.mount(document.createElement(&#x27;div&#x27;))    Object.assign(instance, options, &#123;      visible: true    &#125;)    document.body.appendChild(instance.$el)  &#125;  return instance&#125;ToastFn.close = () =&gt; &#123;  if (instance) &#123;    instance.visible = false  &#125;&#125;export default &#123;  install (app: any) &#123;    app.config.globalProperties.$toast = ToastFn as Function  &#125;&#125;\n\n在main的js注入\n12345import Toast from &#x27;./pages/components/toast&#x27;createApp(App)  .use(Toast)  .mount(&#x27;#app&#x27;)\n\n页面调用\n1234567891011121314151617181920212223242526&lt;template&gt;  &lt;a-button type=&quot;primary&quot; @click=&quot;test&quot;&gt;测试&lt;/a-button&gt;  &lt;br&gt;  &lt;a-button danger @click=&quot;close&quot;&gt;关闭&lt;/a-button&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import &#123;getCurrentInstance&#125; from &#x27;vue&#x27;import type &#123; ComponentInternalInstance &#125; from &#x27;vue&#x27;const &#123; proxy &#125; = getCurrentInstance() as ComponentInternalInstancelet index = 0const test = () =&gt; &#123;  index += 1  proxy?.$toast(&#123;    img: &#x27;https://schbrain-static-online.schbrain.com/resources/ff187df977700d208597993e561d330f.png&#x27;,    text: &#x27;有参数&#x27; + index  &#125;)&#125;const close = () =&gt; &#123;  proxy?.$toast.close()&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;\n\n","slug":"js-singleton","date":"2023-09-20T14:50:32.000Z","categories_index":"","tags_index":"javascript,vue 3.0","author_index":"咸鱼呀"},{"id":"928d3d505cbf4cfd4e085da2a02eebee","title":"开发一个个人的cli","content":"一、脚手架的本质作用和解决了前端的那些问题\n\n\n\n\n\n\n\n\n\n1.为了创建项目的一个基本结构 提供项目规范和约定\n\n相同的组织结构\n相同的开发范式\n相同的模块依赖\n相同的工具配置\n相同的代码基础\n\n\n\n\n\n\n\n\n\n\n\n使用到的包及说明\n\naxios---拉取github模板名和信息\ncommander---nodejs命令行工具\ninquirer---命令行和用户交互工具\nfs-extra---fs的扩展工具，支持promise\nutil---工具类让download-git-repo支持异步\ndownload-git-repo---下载工具（GitHub, GitLab, Bitbucket）\n\n\n\n\n\n未使用到的\n\n\nchalk---为命令行加字体颜色和背景颜色\nora---下载时的loading\nprogress---下载时的进度条\n\n\n\n\n\n\n\n\n\n\n\n2.脚手架就是在启动的时候询问一些简单的问题，并且通过用户回答的结果去渲染对应的模板文件，基本工作流程如下：通过命令行交互询问用户问题根据用户回答的结果生成文件\n二、常用的脚手架工具\n\n\n\n\n\n\n\n\n\nYeoman 通用项目脚手架 灵活易拓展Plop 创建特定类型的文件&#x2F;模块\n三、开始搭建cli\n\n新建项目目录 xianyu-cli \nnpm init 生成 package.json 文件\n\n\n\n创建脚手架入口js和package.json配置信息\n把Npm命令软链到全局\n安装commander\n\n\n1234# 如果软链被占用、可以手动删除一下npm rm ｜ uninstall -g packageName# 如果不确定可以查看一下是否已存在npm ls -g packageName\n\n\n\n\n\n\n\n\n\n\n\n编辑cli.js测试一下代码\n12345678910111213141516171819#! /usr/bin/env nodeconst program = require(&#x27;commander&#x27;) // node 命令行工具program  .version(&#x27;0.1.0&#x27;)  .command(&#x27;create &lt;name&gt;&#x27;)  .description(&#x27;确认创建一个新项目吗？&#x27;)  .action(name =&gt; &#123;    // 打印命令行输入的值    console.log(&#x27;您创建的项目名称为&#x27; + name)  &#125;)program  // 版本号信息  .version(`v$&#123;require(&#x27;../package.json&#x27;).version&#125;`)  .usage(&#x27;&lt;command&gt; [option]&#x27;)program.parse(process.argv)\n\n\n\n\n\n\n\n\n\n\n接下来我们就可以来创建create命令编写create代码安装fs 的扩展工具  fs-extrafs-extra是fs的一个扩展工具，支持 promise 方法，编写create.js时会使用\n123mkdir libtouch create.jsnpm install fs-extra --save\n\n\n在cli.js里引入create.js 并把name和options传进去1234567891011121314...program  .version(&#x27;1.0.0&#x27;)  .command(&#x27;create &lt;name&gt;&#x27;)  .description(&#x27;确认创建一个新项目吗？&#x27;)  // -f or --force 为强制创建，如果创建的目录存在则直接覆盖  .option(&#x27;-f, --force&#x27;, &#x27;强制创建传入&#x27;)  .action((name, options) =&gt; &#123;    // 打印命令行输入的值    console.log(&#x27;您创建的项目名称为&#x27; + name)    // 引入create,把创建任务放在create里执行    require(&#x27;../lib/create.js&#x27;)(name, options)  &#125;)...\n1234567891011121314151617181920212223// lib/create.jsconst path = require(&#x27;path&#x27;)const fs = require(&#x27;fs-extra&#x27;)// 执行创建命令module.exports = async function (name, options) &#123;  console.log(&#x27;您创建的项目名称为&#x27; + name, options)  // 当前命令行选择的目录  const cwd  = process.cwd();  // 需要创建的目录地址  const targetAir  = path.join(cwd, name)  // 目录是否已经存在？  if (fs.existsSync(targetAir)) &#123;    // 存在提示是否为强制创建？ -f --force    if (options.force) &#123;      await fs.remove(targetAir)    &#125; else &#123;      // TODO：询问用户是否确定要覆盖    &#125;  &#125;&#125;\n\n\n\n\n\n\n\n\n\n\n\n接下来创建用户的询问信息询问用户是否进行重写或退出\n12345678910111213141516171819202122232425262728// 上面引入inquirerconst inquirer = require(&#x27;inquirer&#x27;)...// TODO：询问用户是否确定要覆盖let &#123; action &#125; = await inquirer.prompt([  &#123;    name: &#x27;action&#x27;,    type: &#x27;list&#x27;,    message: &#x27;目录已存在，请选择一项继续操作！&#x27;,    choices: [      &#123;        name: &#x27;重写&#x27;,        value: &#x27;重写&#x27;      &#125;,&#123;        name: &#x27;退出&#x27;,        value: false      &#125;    ]  &#125;])if (!action) &#123;  return;&#125; else if (action === &#x27;重写&#x27;) &#123;  // 移除已存在的目录  console.log(`\\r\\nRemoving...`)  await fs.remove(targetAir)&#125;...\n\n\n\n\n\n\n\n\n\n测试截图\n到这里，简易版的cli就搭建完成了\n四、从github生成模板\n1234# 安装axiosnpm install axios --save# 在lib目录下新建 request.js 文件拉取模板列表cd lib &amp;&amp; touch request.js\n1234567891011121314151617181920212223242526272829303132// lib/request.js// 通过 axios 处理请求const axios = require(&#x27;axios&#x27;)axios.interceptors.response.use(res =&gt; &#123;  return res.data;&#125;)/** * 获取模板列表 * @returns Promise */async function getRepoList() &#123;  return axios.get(&#x27;https://api.github.com/users/s-xianyu/repos&#x27;)&#125;/** * 获取版本信息 * @param &#123;string&#125; repo 模板名称 * @returns Promise */async function  getTagList(repo) &#123;  return axios.get(`https://api.github.com/repos/s-xianyu/$&#123;repo&#125;/tags`)&#125;module.exports = &#123;  getRepoList,  getTagList&#125;\n12# 在lib目录下新建 generator.js 用户处理拉取模板创建逻辑代码touch generator.js\n\n\n\n\n\n\n\n\n\n拉取github仓库所有模板\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// lib/generator.jsconst &#123; getRepoList &#125; = require(&#x27;./request&#x27;)const inquirer = require(&#x27;inquirer&#x27;)// 添加加载动画async function wrapLoading(fn, message, ...args) &#123;  console.log(message)  try &#123;    // 执行传入方法 fn    const result = await fn(...args)    return result  &#125; catch (error) &#123;    console.log(&#x27;模板生成失败，请重试！&#x27;)  &#125;&#125;class Generator &#123;  constructor (name, targetDir)&#123;    // 目录名称    this.name = name;    // 创建位置    this.targetDir = targetDir;  &#125;  // 获取用户选择的模板  // 1）从远程拉取模板数据  // 2）用户选择自己新下载的模板名称  // 3）return 用户选择的名称  async getRepo() &#123;    // 1）从远程拉取模板数据    const repoList = await wrapLoading(getRepoList, &#x27;模板获取中，请等待...&#x27;)    if (!repoList.length) return;    // 返回全部    // const repos = repoList.map(item =&gt; item.name))    // 过滤我们需要的模板名称    let repos = []    repoList.map(item =&gt; &#123;      if (item.name.includes(&#x27;uni&#x27;) || item.name.includes(&#x27;vue&#x27;) || item.name.includes(&#x27;xianyu-blog&#x27;)) &#123;        repos.push(item.name)      &#125;    &#125;)    // 2）用户选择自己新下载的模板名称    const &#123; repo &#125; = await inquirer.prompt(&#123;      name: &#x27;repo&#x27;,      type: &#x27;list&#x27;,      choices: repos,      message: &#x27;请选择你要创建的项目模板&#x27;    &#125;)    // 3）return 用户选择的名称    return repo;  &#125;  // 核心创建逻辑  // 1）获取模板名称  // 2）获取 tag 名称  // 3）下载模板到模板目录  async create()&#123;    // 1）获取模板名称    const repo = await this.getRepo()    console.log(&#x27;你选择了项目为:&#x27; + repo)  &#125;&#125;module.exports = Generator;\n\n\n\n\n\n\n\n\n\n拉取模板版本号，更上面的逻辑是一样的不同是需要传一个模板名称过去\n1234567891011121314151617181920212223242526272829async getRepo()&#123;...&#125;async getTag(repo) &#123;  // 1）基于 repo 结果，远程拉取对应的 tag 列表  const tags = await wrapLoading(getTagList, &#x27;版本号获取中，请等待...&#x27;, repo);  if (!tags?.length) return;  // 过滤我们需要的 tag 名称  const tagsList = tags.map(item =&gt; item.name);  // 2）用户选择自己需要下载的 tag  const &#123; tag &#125; = await inquirer.prompt(&#123;    name: &#x27;tag&#x27;,    type: &#x27;list&#x27;,    choices: tagsList,    message: &#x27;请选择版本号&#x27;  &#125;)  // 3）return 用户选择的 tag  return tag&#125;async create()&#123;  // 1）获取模板名称  const repo = await this.getRepo()  // 2) 获取 tag 名称  const tag = await this.getTag(repo)  console.log(&#x27;你选择了项目为:&#x27; + repo + &#x27;，版本号为:&#x27;+ (tag || &#x27;&#x27;))&#125;&#125;\n\n\n\n\n\n\n\n\n\n控制台测试结果 \n五、拉取远程代码到本地\n1234# 安装download-git-reponpm install download-git-repo --save# util工具可以让download-git-repo支持promisenpm install util --save\n\n\n\n\n\n\n\n\n\n编写下载函数\n12345678910111213141516171819202122const util = require(&#x27;util&#x27;)const downloadGitRepo = require(&#x27;download-git-repo&#x27;) // 不支持 Promiseasync create()&#123;  ...  // 3）下载模板到模板目录  await this.download(repo, tag)&#125;async download(repo, tag)&#123;  // 1）拼接下载地址  const requestUrl = `s-xianyu/$&#123;repo&#125;$&#123;tag?&#x27;#&#x27;+tag:&#x27;&#x27;&#125;`;  // 2）调用下载方法  await wrapLoading(    this.downloadGitRepo, // 远程下载方法    &#x27;模板下载中，请稍后...&#x27;, // 加载提示信息    requestUrl, // 参数1: 下载地址    path.resolve(process.cwd(), this.targetDir)) // 参数2: 创建位置&#125;\n12345678# 脚手架的安装与使用npm install -g xianyu-cli22#查看版本xy -V# 使用简写名称拉取模板xy create cli-democd cli-demonpm run server\n\n","slug":"node-cli","date":"2022-02-26T11:36:59.000Z","categories_index":"","tags_index":"node,cli","author_index":"咸鱼呀"},{"id":"fed10f41658f89f01b935a14285ff6c9","title":"nvm-upgrade","content":"##NVM升级\n使用nvm 时报错如下nvm is already installed in &#x2F;usr&#x2F;xxx&#x2F;.nvm, trying to update using git\n\n\n在官方 github issue 中发现以下解决方案,记录一下\n1234567891011set -ecd ~/.nvmgit fetch --tagsTAG=$(git describe --tags `git rev-list --tags --max-count=1`)echo &quot;Checking out tag $TAG...&quot;git checkout &quot;$TAG&quot;source ~/.nvm/nvm.sh\n然后从新开启iTerm命令执行curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash\n重启iTerm \n","slug":"nvm-upgrade","date":"2021-10-11T09:40:24.000Z","categories_index":"","tags_index":"前端,nodeJs","author_index":"咸鱼呀"},{"id":"3006b0f426e269e4b19a1db0dcd311b9","title":"vue 3.0 生命周期函数记录","content":"记录3.0常用方法及属性\n简单两个页面， 主要是查看生命周期\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127&lt;template&gt;\t&lt;div class=&quot;look&quot;&gt;\t\t&lt;h2&gt;Vue3.0 生命周期函数&#123;&#123; num &#125;&#125;&lt;/h2&gt;\t\t&lt;h2&gt;见控制台&lt;/h2&gt;\t\t&lt;br&gt;\t\t&lt;div style=&quot;display: flex;&quot;&gt;\t\t\t&lt;el-button @click=&quot;toggleColor&quot;&gt;toggleColor&lt;/el-button&gt;\t\t\t&lt;span style=&quot;width:20px&quot;&gt;&lt;/span&gt;\t\t\t&lt;el-button @click=&quot;toLook&quot;&gt;toggleLook&lt;/el-button&gt;\t\t&lt;/div&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123;\tdefineComponent,\tonBeforeMount,\tonMounted,\tonBeforeUpdate,\tonUpdated,\tonBeforeUnmount,\tonUnmounted,\tonActivated,\tonDeactivated,\tonErrorCaptured,\tonRenderTracked,\tonRenderTriggered,\tgetCurrentInstance,\treactive,\ttoRefs,    computed,\tref,\tnextTick&#125; from &#x27;vue&#x27;;import &#123; useRouter, useRoute &#125; from &#x27;vue-router&#x27;;export default defineComponent(&#123;\tsetup () &#123;\t\t// 全局对象实例\t\t// ctx.toggleColor（3.0） -- this.toggleColor(2.0)\t\tconst el = getCurrentInstance() as any;\t\t// Router方法 常用addRoute,beforeEach,afterEach\t\tconst Router = useRouter();\t\t// route对象，常用params, query取值\t\tconst Route = useRoute();\t\t// 存储dom数组 需push\t\tconst myRef = ref([]);\t\t// 定义值\t\tconst num = ref&lt;number&gt;(12);\t\t// 定义多个值 2.0里相当于data\t\tconst state = reactive(&#123;\t\t\tcolors: &#x27;red&#x27; // style里可使用\t\t&#125;);        // 创建一个计算属性\t\tconst addAge = computed(() =&gt; el.ctx.num++ );\t\t// 生命周期\t\tonBeforeMount(() =&gt; &#123;\t\t\tconsole.log(el);\t\t\tconsole.log(Route.query.id);\t\t\tconsole.log(&#x27;onBeforeMount&#x27;, 1);\t\t&#125;);\t\tonMounted(() =&gt; &#123;\t\t\tconsole.log(&#x27;onMounted&#x27;, 2);\t\t&#125;);\t\tonBeforeUpdate(() =&gt; &#123;\t\t\tconsole.log(&#x27;onBeforeUpdate&#x27;, 3);\t\t&#125;);\t\tonUpdated(() =&gt; &#123;\t\t\tconsole.log(&#x27;onUpdated&#x27;, 4);\t\t&#125;);\t\tonBeforeUnmount(() =&gt; &#123;\t\t\tconsole.log(&#x27;onBeforeUnmount&#x27;, 5);\t\t&#125;);\t\tonUnmounted(() =&gt; &#123;\t\t\tconsole.log(&#x27;onUnmounted&#x27;, 6);\t\t&#125;);\t\tonActivated(() =&gt; &#123;\t\t\tconsole.log(&#x27;onActivated&#x27;, 7);\t\t&#125;);\t\tonDeactivated(() =&gt; &#123;\t\t\tconsole.log(&#x27;onDeactivated&#x27;, 8);\t\t&#125;);\t\tonErrorCaptured(() =&gt; &#123;\t\t\tconsole.log(&#x27;onErrorCaptured&#x27;, 9);\t\t&#125;);\t\tonRenderTracked((e) =&gt; &#123;\t\t\tdebugger;\t\t\tconsole.log(&#x27;onRenderTracked&#x27;, e);\t\t&#125;);\t\tonRenderTriggered((e) =&gt; &#123;\t\t\tdebugger;\t\t\tconsole.log(&#x27;onRenderTriggered&#x27;, e);\t\t&#125;);\t\tconst toLook = () =&gt; &#123;\t\t\tRouter.push(&#123;\t\t\t\tname: &#x27;toggleLook&#x27;\t\t\t&#125;);\t\t&#125;;\t\tconst methods = &#123;\t\t\ttoggleColor: () =&gt; &#123;\t\t\t\tstate.colors = state.colors === &#x27;red&#x27; ? &#x27;blue&#x27; : &#x27;red&#x27;;\t\t\t&#125;\t\t&#125;;\t\treturn &#123;\t\t\tnum,\t\t\ttoLook,\t\t\t...toRefs(state),\t\t\t...methods\t\t&#125;;\t&#125;&#125;);&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;.look&#123;\twidth:100vw;\theight:100vh;\tdisplay: flex;\tflex-direction: column;\tjustify-content: center;\talign-items: center;\tcolor: v-bind(colors);\th2&#123;\t\tdisplay: flex;\t&#125;&#125;&lt;/style&gt;\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;template&gt;\t&lt;div class=&quot;look&quot;&gt;\t\t&lt;h2&gt;Vue3.0 生命周期函数&lt;/h2&gt;\t\t&lt;h2&gt;见控制台&lt;/h2&gt;\t\t&lt;br&gt;\t\t&lt;el-button @click=&quot;toLook&quot;&gt;toggleLook&lt;/el-button&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123;\tdefineComponent,\tonBeforeMount,\tonMounted,\tonBeforeUpdate,\tonUpdated,\tonBeforeUnmount,\tonUnmounted,\tonActivated,\tonDeactivated,\tonErrorCaptured,\tonRenderTracked,\tonRenderTriggered&#125; from &#x27;vue&#x27;;import &#123; useRouter &#125; from &#x27;vue-router&#x27;;export default defineComponent(&#123;\tsetup () &#123;\t\tconst Router = useRouter();\t\tonBeforeMount(() =&gt; &#123;\t\t\tconsole.log(&#x27;onBeforeMount&#x27;, 1);\t\t&#125;);\t\tonMounted(() =&gt; &#123;\t\t\tconsole.log(&#x27;onMounted&#x27;, 2);\t\t&#125;);\t\tonBeforeUpdate(() =&gt; &#123;\t\t\tconsole.log(&#x27;onBeforeUpdate&#x27;, 3);\t\t&#125;);\t\tonUpdated(() =&gt; &#123;\t\t\tconsole.log(&#x27;onUpdated&#x27;, 4);\t\t&#125;);\t\tonBeforeUnmount(() =&gt; &#123;\t\t\tconsole.log(&#x27;onBeforeUnmount&#x27;, 5);\t\t&#125;);\t\tonUnmounted(() =&gt; &#123;\t\t\tconsole.log(&#x27;onUnmounted&#x27;, 6);\t\t&#125;);\t\tonActivated(() =&gt; &#123;\t\t\tconsole.log(&#x27;onActivated&#x27;, 7);\t\t&#125;);\t\tonDeactivated(() =&gt; &#123;\t\t\tconsole.log(&#x27;onDeactivated&#x27;, 8);\t\t&#125;);\t\tonErrorCaptured(() =&gt; &#123;\t\t\tconsole.log(&#x27;onErrorCaptured&#x27;, 9);\t\t&#125;);\t\tonRenderTracked((e) =&gt; &#123;\t\t\tdebugger;\t\t\tconsole.log(&#x27;onRenderTracked&#x27;, e);\t\t&#125;);\t\tonRenderTriggered((e) =&gt; &#123;\t\t\tdebugger;\t\t\tconsole.log(&#x27;onRenderTriggered&#x27;, e);\t\t&#125;);\t\tconst toLook = () =&gt; &#123;\t\t\tRouter.push(&#123;\t\t\t\tname: &#x27;look&#x27;,\t\t\t\tquery: &#123;\t\t\t\t\tid: &#x27;xianyu&#x27;\t\t\t\t&#125;\t\t\t&#125;);\t\t&#125;;\t\treturn &#123;\t\t\ttoLook\t\t&#125;;\t&#125;&#125;);&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;.look&#123;\twidth:100vw;\theight:100vh;\tdisplay: flex;\tflex-direction: column;\tjustify-content: center;\talign-items: center;\th2&#123;\t\tdisplay: flex;\t&#125;&#125;&lt;/style&gt;\n","slug":"vue3-record","date":"2021-06-27T02:03:26.000Z","categories_index":"","tags_index":"前端,vue 3.0","author_index":"咸鱼呀"},{"id":"e0b5cfb0ffceb545d85968bbf214a8c9","title":"Vue组件打包到发布流程","content":"一. npm是什么   npm（全称 Node Package Manager，即“node包管理器”）是Node.js默认的、用JavaScript编写的软件包管理系统。\n\n\n二.npm发展史   npm 的发展是跟 Node.js 的发展相辅相成的,NodeJs是由在德国工作的美国程序员 瑞安.达尔(Ryan Dahl) 的，他写了 Node.js，但是 Node.js 缺少一个包管理器，于是他和 npm 的作者一拍即合、抱团取暖，最终 Node.js 内置了 npm   npm完全用JavaScript写成，最初由艾萨克·施吕特（Isaac Z. Schlueter）开发。艾萨克表示自己意识到“模块管理很糟糕”的问题，并看到了PHP的PEAR与Perl的CPAN等软件的缺点，于是编写了npm。2020年3月16 日，GitHub CEO 奈特·弗里德曼 (Nat Friedman) 宣布 GitHub 已签署收购 NPM（npm 背后的公司）的协议，并表示 npm 加入 GitHub 后会继续免费提供公共软件注册中心服务。\n三.组件开发 1.使用vue-cli构建一个项目\n1vue create xianyuNpm\n\n 2.新建文件夹packages用于存放组件（vue开发组件可以放在这里里面）\ncountNumber.vue测试代码\n123456789101112131415161718192021&lt;template&gt;  &lt;div class=&quot;count-number&quot; :style=&quot;&#123;color: color, fontSize: size + &#x27;px&#x27;&#125;&quot;&gt;    &lt;slot/&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#x27;countNumber&#x27;,  props: &#123;    color: &#123;      type: String,      default: &#x27;red&#x27;    &#125;,    size: &#123;      type: String,      default: &#x27;12&#x27;    &#125;  &#125;&#125;&lt;/script&gt;\n\ncountNumber同级index.js\n123456789101112131415161718192021222324import CountNumber from &#x27;./countNumber&#x27;// 存储组件列表const components = [    CountNumber]/*  定义install 方法，接收Vue作为参数，如果使用use注册插件，则所有的组件都将被注册*/const install = function (Vue) &#123;    // 判断是否安装    if(install.installed)&#123;return&#125;    // 遍历所有组件    components.map(item =&gt; &#123;        Vue.component(item.name,item)    &#125;)&#125;// 判断是否引入文件if(typeof window !== &#x27;undefined&#x27; &amp;&amp; window.Vue)&#123;    install(window.Vue)&#125;export default&#123;    install,    CountNumber&#125;\n\npackages下的index.js\n123456789101112131415161718192021222324import CountNumber from &#x27;./countNumber&#x27;// 存储组件列表const components = [    CountNumber]/*  定义install 方法，接收Vue作为参数，如果使用use注册插件，则所有的组件都将被注册*/const install = function (Vue) &#123;    // 判断是否安装    if(install.installed)&#123;return&#125;    // 遍历所有组件    components.map(item =&gt; &#123;        Vue.component(item.name,item)    &#125;)&#125;// 判断是否引入文件if(typeof window !== &#x27;undefined&#x27; &amp;&amp; window.Vue)&#123;    install(window.Vue)&#125;export default&#123;    install,    CountNumber&#125;\n\n3.新建vue.config.js文件（项目打包配置）\n1234567891011121314151617181920212223242526272829303132module.exports = &#123;    devServer: &#123;        port: 4000,    &#125;,    // 修改 examples 目录 为 examples 目录    pages: &#123;        index: &#123;            // page 的入口            entry: &#x27;examples/main.js&#x27;,   // 把src 修改为examples            // 模板来源            template: &#x27;public/index.html&#x27;,            // 在 dist/index.html 的输出            filename: &#x27;index.html&#x27;        &#125;    &#125;,    // 扩展 webpack 配置，使 packages 加入编译    /* chainWebpack 是一个函数，会接收一个基于 webpack-chain 的 ChainableConfig 实例。允许对内部的 webpack 配置进行更细粒度的修改。 */    chainWebpack: config =&gt; &#123;        config.module            .rule(&#x27;js&#x27;)            .include            .add(__dirname + &#x27;packages&#x27;)  // 注意这里需要绝对路径，所有要拼接__dirname            .end()            .use(&#x27;babel&#x27;)            .loader(&#x27;babel-loader&#x27;)            .tap(options =&gt; &#123;                // 修改它的选项...                return options            &#125;)    &#125;&#125;\n\n 4.配置打包文件（package.json）\n123456789101112131415161718192021222324252627282930313233343536373839404142434445&#123;   // 包名，该名字是唯一的。可在 npm 官网搜索名字，如果存在则需换个名字。  &quot;name&quot;: &quot;woshiyitiaoxianyu-npm&quot;,  // 版本号，每次发布至 npm 需要修改版本号，不能和历史版本号相同。  &quot;version&quot;: &quot;1.0.3&quot;,  // 是否私有，需要修改为 false 才能发布到 npm  &quot;private&quot;: false,  // 项目描述  &quot;description:&quot;: &quot;我是一条咸鱼&quot;,  // 作者  &quot;author&quot;: &quot;xianyuya &lt;s22529634@aliyun.com&gt;&quot;,  &quot;license&quot;: &quot;MIT&quot;, // 开源协议  // 项目官网的地址  &quot;homepage&quot;: &quot;http:// blob/xianyuya.ltd/&quot;,  // 入口文件，该字段需指向我们最终编译后的包文件  &quot;main&quot;: &quot;lib/woshiyitiaoxianyu-npm.umd.min.js&quot;,   // 关键字，以空格分离希望用户最终搜索的词或者数组形式  &quot;keywords&quot;: [    &quot;vue&quot;,    &quot;countNumber&quot;  ],  // 项目仓库  &quot;repository&quot;: &#123;    &quot;type&quot;: &quot;git&quot;,    &quot;url&quot;: &quot;https://github.com/s-xianyu/xianyuNpm.git&quot;  &#125;,  // 指定打包后,包中存在的文件夹  &quot;files&quot;: [    &quot;lib&quot;,    &quot;packages&quot;,    &quot;examples&quot;  ],  &quot;scripts&quot;: &#123;    // --target 构建目标，默认为应用模式。这里修改为 lib 启用库模式    // --name 打包生成的包名    // --dest 输出目录，默认 dist。这里我们改成 lib    // [entry] 最后一个参数为入口文件，默认为 src/App.vue。这里我们指定编译 packages/ 组件库目录    &quot;lib&quot;: &quot;vue-cli-service build --target lib --name woshiyitiaoxianyu-npm --dest lib packages/index.js&quot;,    &quot;serve&quot;: &quot;vue-cli-service serve&quot;,    &quot;build&quot;: &quot;vue-cli-service build&quot;,    &quot;lint&quot;: &quot;vue-cli-service lint&quot;,    &quot;publish&quot;: &quot;publish&quot;  &#125;,&#125;\n\n\n四. 发布 到npm官网 注册账号然后到项目中登录\n1234567891011// 登录npm login// 发布npm publish// 从注册表中删除软件包npm unpublish [&lt;@scope&gt;/]&lt;pkg&gt;[@&lt;version&gt;]npx force-unpublish package-name &#x27;原因描述&#x27;// 查看当前登录账户 npm whoami      \n\n 发布过程中首先要切换镜像\n1234567891011121314151617181920查看npm源地址，在终端输入以下命令npm config list修改registry地址npm config set registry http://registry.npmjs.org  // 官网镜像地址npm set registry https://registry.npm.taobao.org/ // 淘宝镜像地址// 或者直接装nrm mac前面加sudonpm install nrm -g --save// 查看所有源nrm ls//查看当前源nrm current// 切换nrm use cnpm// 用nrm add 命令添加公司私有npm源nrm add qihoo http://registry.npm.xianyu.org// 测试速度nrm test npm// 删除镜像源nrm del npm\n\n\n","slug":"npm-build","date":"2021-04-24T15:47:20.000Z","categories_index":"","tags_index":"javascript,node,npm","author_index":"咸鱼呀"},{"id":"8edc8d62dda1f9cdaa862f60478e3e71","title":"NVM 安装 之 window","content":"1.首先下载nvm安装包官方地址：https://github.com/coreybutler/nvm-windows/releases\n推荐下载：  nvm-setup.zip  \n\n2.安装一路安装下去，安装成功后在命令行输入nvm会显示成功状态\n3.配置淘宝镜像提升速度由于nvm默认的下载地址http://nodejs.org/dist/是外国外服务器，速度非常慢，因而可以切换到淘宝的镜像，下载速度会快很多。打开nvm的安装路径，默认安装路径是：C:\\Users\\EDZ\\AppData\\Roaming\\nvm\\settings.txt打开settings.txt，加入下面文件\narch: 64  proxy: nonenode_mirror: http://npm.taobao.org/mirrors/node/npm_mirror: https://npm.taobao.org/mirrors/npm/\n4.安装node，切换版本nvm  install version\n看到这一步时说明已经安装成功。\n接下来就是查看node已安装版本，命令：nvm list 简写nvm ls可以看到目前安装了3个版本。3个版本直接可以任意切换 命令 nvm use version可以看到，我的版本是12.16.2. 当执行nvm use 10.0.0 之后，在查看node -v时，版本已经切换为10.0.0了。\n5.node 版本卸载nvm uninstall version\n","slug":"nvm-window","date":"2020-07-03T16:00:17.000Z","categories_index":"","tags_index":"前端,nodeJs","author_index":"咸鱼呀"},{"id":"d18c61dbe504def289447aed632d6a4f","title":"解决ios端inout失焦时，底部白底","content":"经常在ios端遇见键盘弹起后，带起input框上拉，当键盘关闭后，input没有回到原来的位置，这时，ios底部会有键盘收起后的留白。\n想要解决这种问题，需要在键盘弹起、关闭时监听，设置scrollTo（top:0, left:0, behavior: ‘smooth’）\n下面是代码↓\n\n\n123456789101112131415161718192021222324252627282930mounted() &#123;  // ios底部留白      this.iosWhite()&#125;,methods() &#123;  iosWhite() &#123;        const u = navigator.userAgent        let flag        let myFunction        const isIOS = !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/)        if (isIOS) &#123;          document.body.addEventListener(&#x27;focusin&#x27;, () =&gt; &#123; // 软键盘弹起事件            flag = true            clearTimeout(myFunction)          &#125;)          document.body.addEventListener(&#x27;focusout&#x27;, () =&gt; &#123; // 软键盘关闭事件            flag = false            if (!flag) &#123;              myFunction = setTimeout(() =&gt; &#123;                window.scrollTo(&#123; top: 0, left: 0, behavior: &#x27;smooth&#x27; &#125;)// 重点  =======当键盘收起的时候让页面回到原始位置(这里的top可以根据你们个人的需求改变，并不一定要回到页面顶部)              &#125;, 200)            &#125; else &#123;              return            &#125;          &#125;)        &#125; else &#123;          return        &#125;  &#125;,&#125;\n","slug":"web-Ios-Android","date":"2020-07-01T16:26:23.000Z","categories_index":"","tags_index":"前端,H5","author_index":"咸鱼呀"},{"id":"aa61b3833f4b0085491ebb8181f41aa4","title":"WebStorm配置本地测试服务器","content":"1.﻿﻿ 点击Settings 进入设置2.﻿﻿ 选择 Build, Execution, Deployment 下的 Debuggera. 将端口号 63342 改为 8080b. 勾选Can accept external connections(可以接受外部连接)\n\n3. 选择 Build, Execution, Deployment 下的 Deploymenta. 点击”+”号，增加一条规则b. 设置 Name 为 localhost，Type 设置为 Local or mounted folder(本地或安装文件夹)4.选择 Connectiona. Folder 设为本地前端页面文件夹路径b. Web server root URL 设为本机的IP和8080端口c. 电脑运行 cmd 打开终端 输入 ipconfig 命令 查询本机IP地址5.选择 Mappingsa. Local path 设置为本地前端页面文件夹路径b. Web path on server ‘localhost ‘ 设置为 前端页面的文件夹\n","slug":"WebStorm-server","date":"2020-05-29T16:23:58.000Z","categories_index":"","tags_index":"工具","author_index":"咸鱼呀"},{"id":"05c97d7c428939aa3109e9f2fad8afe5","title":"一个好看的loading","content":"\n\n直接上代码\n12345678910111213141516171819202122232425.loading&#123;    display: inline-block;    width: 51px;    height: 51px;    margin: 6px;    border-radius: 50%;    background: #ef3795;    animation: lds-circle 2.4s cubic-bezier(0, 0.2, 0.8, 1) infinite;  &#125;@keyframes lds-circle &#123;    0%, 100% &#123;      animation-timing-function: cubic-bezier(0.5, 0, 1, 0.5);    &#125;    0% &#123;      transform: rotateY(0deg);    &#125;    50% &#123;      transform: rotateY(1800deg);      animation-timing-function: cubic-bezier(0, 0.5, 0.5, 1);    &#125;    100% &#123;      transform: rotateY(3600deg);    &#125;  &#125;\n\n","slug":"css-loading","date":"2020-01-04T16:30:42.000Z","categories_index":"","tags_index":"css","author_index":"咸鱼呀"},{"id":"d65deff85057352556537b323c50233d","title":"正则常用表达式","content":"1234567891011121314151617181920212223242526272829303132333435export const regExpConfig = &#123;  IDcard: /^[1-9]\\d&#123;7&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d&#123;3&#125;$|^[1-9]\\d&#123;5&#125;[1-9]\\d&#123;3&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d&#123;3&#125;([0-9]|X)$/, // 身份证  mobile: /^1([3|4|5|7|8|])\\d&#123;9&#125;$/, // 手机号码  telephone: /^(\\(\\d&#123;3,4&#125;\\)|\\d&#123;3,4&#125;-|\\s)?\\d&#123;7,14&#125;$/, // 固定电话  num: /^[0-9]*$/, // 数字  phoneNo: /(^1([3|4|5|7|8|])\\d&#123;9&#125;$)|(^(\\(\\d&#123;3,4&#125;\\)|\\d&#123;3,4&#125;-|\\s)?\\d&#123;7,14&#125;$)/, // 电话或者手机  policeNo: /^[0-9A-Za-z]&#123;4,10&#125;$/, // 账号4-10位数字或字母组成  pwd: /^[0-9A-Za-z]&#123;6,16&#125;$/, // 密码由6-16位数字或者字母组成  isNumAlpha: /^[0-9A-Za-z]*$/, // 字母或数字  isAlpha: /^[a-zA-Z]*$/, // 是否字母  isNumAlphaCn: /^[0-9a-zA-Z\\u4E00-\\uFA29]*$/, // 是否数字或字母或汉字  isPostCode: /^[\\d-]*$/i, // 是否邮编  isNumAlphaUline: /^[0-9a-zA-Z_]*$/, // 是否数字、字母或下划线  isNumAndThanZero: /^([1-9]\\d*(\\.\\d+)?|0)$/, // 是否为整数且大于0/^[1-9]\\d*(\\.\\d+)?$/  isNormalEncode: /^(\\w||[\\u4e00-\\u9fa5])&#123;0,&#125;$/, // 是否为非特殊字符（包括数字字母下划线中文）  isTableName: /^[a-zA-Z][A-Za-z0-9#$_-]&#123;0,29&#125;$/, // 表名  isInt: /^-?\\d+$/, // 整数  isTableOtherName: /^[\\u4e00-\\u9fa5]&#123;0,20&#125;$/, // 别名  // isText_30: /^(\\W|\\w&#123;1,2&#125;)&#123;0,15&#125;$/, // 正则  // isText_20: /^(\\W|\\w&#123;1,2&#125;)&#123;0,10&#125;$/, // 正则  isText_30: /^(\\W|\\w&#123;1&#125;)&#123;0,30&#125;$/, // 匹配30个字符，字符可以使字母、数字、下划线、非字母，一个汉字算1个字符  isText_50: /^(\\W|\\w&#123;1&#125;)&#123;0,50&#125;$/, // 匹配50个字符，字符可以使字母、数字、下划线、非字母，一个汉字算1个字符  isText_20: /^(\\W|\\w&#123;1&#125;)&#123;0,20&#125;$/, // 匹配20个字符，字符可以使字母、数字、下划线、非字母，一个汉字算1个字符  isText_100: /^(\\W|\\w&#123;1&#125;)&#123;0,100&#125;$/, // 匹配100个字符，字符可以使字母、数字、下划线、非字母，一个汉字算1个字符  isText_250: /^(\\W|\\w&#123;1&#125;)&#123;0,250&#125;$/, // 匹配250个字符，字符可以使字母、数字、下划线、非字母，一个汉字算1个字符  isNotChina: /^[^\\u4e00-\\u9fa5]&#123;0,&#125;$/, // 不为中文  IDcard: /^[1-9]\\d&#123;7&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d&#123;3&#125;$|^[1-9]\\d&#123;5&#125;[1-9]\\d&#123;3&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d&#123;3&#125;([0-9]|X)$/, // 身份证  IDcardAndAdmin: /^(([1-9]\\d&#123;7&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d&#123;3&#125;$|^[1-9]\\d&#123;5&#125;[1-9]\\d&#123;3&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d&#123;3&#125;([0-9]|X))|(admin))$/, // 身份证或者是admin账号  IDcardTrim: /^\\s*(([1-9]\\d&#123;7&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d&#123;3&#125;)|([1-9]\\d&#123;5&#125;[1-9]\\d&#123;3&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d&#123;3&#125;([0-9]|X))|(admin))\\s*$/, // 身份证  num1: /^[1-9]*$/, // 数字  companyNO: /^qqb_[0-9a-zA-Z_]&#123;1,&#125;$/, // 公司人员账号  imgType: /image\\/(png|jpg|jpeg|gif)$/, // 上传图片类型  isChina: /^[\\u4e00-\\u9fa5]&#123;2,8&#125;$/,  isNozeroNumber: /^\\+?[1-9]\\d*$/, // 大于零的正整数  float: /^\\d+(\\.?|(\\.\\d+)?)$/, // 匹配正整数或者小数 或者0.这个特殊值&#125;\n","slug":"regular","date":"2019-12-20T19:45:40.000Z","categories_index":"","tags_index":"前端","author_index":"咸鱼呀"},{"id":"5d91f091b751e7ba7fe059e9f623df0f","title":"JS工具函数-转载","content":"JS工具函数-转载1、isStatic：检测数据是不是除了symbol外的原始数据123456789function isStatic(value) &#123;   return(          typeof value === &#x27;string&#x27; ||     typeof value === &#x27;number&#x27; ||       typeof value === &#x27;boolean&#x27; ||      typeof value === &#x27;undefined&#x27; ||      value === null     )&#125;\n\n\n2、isPrimitive：检测数据是不是原始数据123function isPrimitive(value) &#123;   return isStatic(value) || typeof value === &#x27;symbol&#x27;&#125;\n\n\n3、isObject：判断数据是不是引用类型的数据 (例如： arrays, functions, objects, regexes, new Number(0),以及 new String(‘’))1234function isObject(value) &#123;    let type = typeof value;    return value != null &amp;&amp; (type == &#x27;object&#x27; || type == &#x27;function&#x27;);&#125;\n\n\n4、isObjectLike：检查 value 是否是 类对象。 如果一个值是类对象，那么它不应该是 null，而且 typeof 后的结果是 “object”123function isObjectLike(value) &#123;   return value != null &amp;&amp; typeof value == &#x27;object&#x27;;&#125;\n\n\n5、getRawType：获取数据类型，返回结果为 Number、String、Object、Array等1function getRawType(value) &#123;    return Object.prototype.toString.call(value).slice(8, -1)&#125;//getoRawType([]) ==&gt; Array\n\n\n6、isPlainObject：判断数据是不是Object类型的数据123function isPlainObject(obj) &#123;  return Object.prototype.toString.call(obj) === &#x27;[object Object]&#x27;&#125;\n\n\n7、isArray：判断数据是不是数组类型的数据123function isArray(arr) &#123;  return Object.prototype.toString.call(arr) === &#x27;[object Array]&#x27;&#125;\n将isArray挂载到Array上\n1Array.isArray = Array.isArray || isArray;\n\n\n8、isRegExp：判断数据是不是正则对象123function isRegExp(value) &#123;   return Object.prototype.toString.call(value) === &#x27;[object RegExp]&#x27;&#125;\n\n\n9、isDate：判断数据是不是时间对象123function isDate(value) &#123;   return Object.prototype.toString.call(value) === &#x27;[object Date]&#x27;&#125;\n\n\n10、isNative：判断 value 是不是浏览器内置函数内置函数toString后的主体代码块为 [native code] ，而非内置函数则为相关代码，所以非内置函数可以进行拷贝(toString后掐头去尾再由Function转)\n123function isNative(value) &#123;   return typeof value === &#x27;function&#x27; &amp;&amp; /native code/.test(value.toString())&#125;\n\n\n11、isFunction：检查 value 是不是函数123function isFunction(value) &#123;    return Object.prototype.toString.call(value) === &#x27;[object Function]&#x27;&#125;\n\n\n12、isLength：检查 value 是否为有效的类数组长度1234function isLength(value) &#123;    return typeof value == &#x27;number&#x27; &amp;&amp;    value &gt; -1 &amp;&amp; value % 1 == 0 &amp;&amp; value &lt;= Number.MAX_SAFE_INTEGER;&#125;\n\n\n13、isArrayLike：检查 value 是否是类数组如果一个值被认为是类数组，那么它不是一个函数，并且value.length是个整数，大于等于 0，小于或等于 Number.MAX_SAFE_INTEGER。这里字符串也将被当作类数组。\n123function isArrayLike(value) &#123;    return value != null &amp;&amp; isLength(value.length) &amp;&amp; !isFunction(value);&#125;\n\n\n14、isEmpty：检查 value 是否为空如果是null，直接返回true；如果是类数组，判断数据长度；如果是Object对象，判断是否具有属性；如果是其他数据，直接返回false(也可改为返回true)\n123456789101112131415function isEmpty(value) &#123;   if (value == null) &#123;     return true;     &#125;     if (isArrayLike(value)) &#123;    return !value.length;    &#125;else if(isPlainObject(value))&#123;    for (let key in value) &#123;        if (hasOwnProperty.call(value, key)) &#123;           return false;             &#125;        &#125;     &#125;     return false;&#125;\n\n\n15、cached：记忆函数：缓存函数的运算结果1234567function cached(fn) &#123;   let cache = Object.create(null);   return function cachedFn(str) &#123;     let hit = cache[str];      return hit || (cache[str] = fn(str))   &#125;&#125;\n\n\n\n16、camelize：横线转驼峰命名1234567let camelizeRE = /-(\\w)/g;function camelize(str) &#123;  return str.replace(camelizeRE, function(_, c) &#123;     return c ? c.toUpperCase() : &#x27;&#x27;;      &#125;)&#125;//ab-cd-ef ==&gt; abCdEf//使用记忆函数let _camelize = cached(camelize)\n\n\n17、hyphenate：驼峰命名转横线命名：拆分字符串，使用 - 相连，并且转换为小写12345let hyphenateRE = /\\B([A-Z])/g;function hyphenate(str)&#123;  return str.replace(hyphenateRE, &#x27;-$1&#x27;).toLowerCase()&#125;//abCd ==&gt; ab-cd//使用记忆函数let _hyphenate = cached(hyphenate);\n\n\n18、capitalize：字符串首位大写1234function capitalize(str)&#123;   return str.charAt(0).toUpperCase() + str.slice(1)&#125;// abc ==&gt; Abc//使用记忆函数let _capitalize = cached(capitalize)\n\n\n19、extend：将属性混合到目标对象中123456function extend(to, _from) &#123;   for(let key in _from) &#123;      to[key] = _from[key];     &#125;     return to&#125;\n\n\n20、Object.assign：对象属性复制，浅拷贝123456789101112Object.assign = Object.assign || function()&#123;   if(arguments.length == 0) throw new TypeError(&#x27;Cannot convert undefined or null to object&#x27;);  let target = arguments[0],        args = Array.prototype.slice.call(arguments, 1),      key     args.forEach(function(item)&#123;      for(key in item)&#123;          item.hasOwnProperty(key) &amp;&amp; ( target[key] = item[key] )     &#125;    &#125;)    return target&#125;\n使用Object.assign可以浅克隆一个对象\n1let clone = Object.assign(&#123;&#125;, target)\n简单的深克隆可以使用JSON.parse()和JSON.stringify()，这两个api是解析json数据的，所以只能解析除symbol外的原始类型及数组和对象\n1let clone = JSON.parse( JSON.stringify(target) )\n\n\n21、clone：克隆数据，可深度克隆这里列出了原始类型，时间、正则、错误、数组、对象的克隆规则，其他的可自行补充\n12345678910111213141516171819202122232425function clone(value, deep)&#123;   if(isPrimitive(value))&#123;    return value     &#125;          if (isArrayLike(value)) &#123;    //是类数组      value = Array.prototype.slice.call(value)    return value.map(item =&gt; deep ? clone(item, deep) : item)    &#125;else if(isPlainObject(value))&#123;    //是对象              let target = &#123;&#125;, key;     for (key in value) &#123;       value.hasOwnProperty(key) &amp;&amp; ( target[key] = deep ? clone(value[key], deep) : value[key] )       &#125;     &#125;     let type = getRawType(value)    switch(type)&#123;      case &#x27;Date&#x27;:       case &#x27;RegExp&#x27;:      case &#x27;Error&#x27;:      value = new window[type](value);       break;     &#125;      return value&#125;\n\n\n22、识别各种浏览器及平台12345678910111213//运行环境是浏览器let inBrowser = typeof window !== &#x27;undefined&#x27;;//运行环境是微信let inWeex = typeof WXEnvironment !== &#x27;undefined&#x27; &amp;&amp; !!WXEnvironment.platform;let weexPlatform = inWeex &amp;&amp; WXEnvironment.platform.toLowerCase();//浏览器 UA 判断let UA = inBrowser &amp;&amp; window.navigator.userAgent.toLowerCase();let isIE = UA &amp;&amp; /msie|trident/.test(UA);let isIE9 = UA &amp;&amp; UA.indexOf(&#x27;msie 9.0&#x27;) &gt; 0;let isEdge = UA &amp;&amp; UA.indexOf(&#x27;edge/&#x27;) &gt; 0;let isAndroid = (UA &amp;&amp; UA.indexOf(&#x27;android&#x27;) &gt; 0) || (weexPlatform === &#x27;android&#x27;);let isIOS = (UA &amp;&amp; /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === &#x27;ios&#x27;);let isChrome = UA &amp;&amp; /chrome\\/\\d+/.test(UA) &amp;&amp; !isEdge;\n\n\n23、getExplorerInfo：获取浏览器信息12345678910111213141516171819202122232425262728function getExplorerInfo() &#123;    let t = navigator.userAgent.toLowerCase();    return 0 &lt;= t.indexOf(&quot;msie&quot;) ? &#123; //ie &lt; 11        type: &quot;IE&quot;,        version: Number(t.match(/msie ([\\d]+)/)[1])    &#125; : !!t.match(/trident\\/.+?rv:(([\\d.]+))/) ? &#123; // ie 11        type: &quot;IE&quot;,        version: 11    &#125; : 0 &lt;= t.indexOf(&quot;edge&quot;) ? &#123;        type: &quot;Edge&quot;,        version: Number(t.match(/edge\\/([\\d]+)/)[1])    &#125; : 0 &lt;= t.indexOf(&quot;firefox&quot;) ? &#123;        type: &quot;Firefox&quot;,        version: Number(t.match(/firefox\\/([\\d]+)/)[1])    &#125; : 0 &lt;= t.indexOf(&quot;chrome&quot;) ? &#123;        type: &quot;Chrome&quot;,        version: Number(t.match(/chrome\\/([\\d]+)/)[1])    &#125; : 0 &lt;= t.indexOf(&quot;opera&quot;) ? &#123;        type: &quot;Opera&quot;,        version: Number(t.match(/opera.([\\d]+)/)[1])    &#125; : 0 &lt;= t.indexOf(&quot;Safari&quot;) ? &#123;        type: &quot;Safari&quot;,        version: Number(t.match(/version\\/([\\d]+)/)[1])    &#125; : &#123;        type: t,        version: -1    &#125;&#125;\n\n\n24、isPCBroswer：检测是否为PC端浏览器模式123456789101112function isPCBroswer() &#123;    let e = navigator.userAgent.toLowerCase()        , t = &quot;ipad&quot; == e.match(/ipad/i)        , i = &quot;iphone&quot; == e.match(/iphone/i)        , r = &quot;midp&quot; == e.match(/midp/i)        , n = &quot;rv:1.2.3.4&quot; == e.match(/rv:1.2.3.4/i)        , a = &quot;ucweb&quot; == e.match(/ucweb/i)        , o = &quot;android&quot; == e.match(/android/i)        , s = &quot;windows ce&quot; == e.match(/windows ce/i)        , l = &quot;windows mobile&quot; == e.match(/windows mobile/i);    return !(t || i || r || n || a || o || s || l)&#125;\n\n\n25、unique：数组去重，返回一个新数组12345678910111213141516171819202122232425function unique(arr)&#123;    if(!isArrayLink(arr))&#123; //不是类数组对象        return arr    &#125;    let result = []    let objarr = []    let obj = Object.create(null)        arr.forEach(item =&gt; &#123;        if(isStatic(item))&#123;//是除了symbol外的原始数据            let key = item + &#x27;_&#x27; + getRawType(item);            if(!obj[key])&#123;                obj[key] = true                result.push(item)            &#125;        &#125;else&#123;//引用类型及symbol            if(!objarr.includes(item))&#123;                objarr.push(item)                result.push(item)            &#125;        &#125;    &#125;)        return resulte&#125;\n\n\n26、Set简单实现12345678910111213141516171819202122232425262728293031323334353637383940window.Set = window.Set || (function () &#123;    function Set(arr) &#123;        this.items = arr ? unique(arr) : [];        this.size = this.items.length; // Array的大小    &#125;    Set.prototype = &#123;        add: function (value) &#123;            // 添加元素,若元素已存在,则跳过，返回 Set 结构本身。            if (!this.has(value)) &#123;                this.items.push(value);                this.size++;            &#125;            return this;        &#125;,        clear: function () &#123;            //清除所有成员，没有返回值。            this.items = []            this.size = 0        &#125;,        delete: function (value) &#123;            //删除某个值，返回一个布尔值，表示删除是否成功。            return this.items.some((v, i) =&gt; &#123;                if(v === value)&#123;                    this.items.splice(i,1)                    return true                &#125;                return false            &#125;)        &#125;,        has: function (value) &#123;            //返回一个布尔值，表示该值是否为Set的成员。            return this.items.some(v =&gt; v === value)        &#125;,        values: function () &#123;            return this.items        &#125;,    &#125;    return Set;&#125;());\n\n\n27、repeat：生成一个重复的字符串，有n个str组成，可修改为填充为数组等1234567891011121314function repeat(str, n) &#123;    let res = &#x27;&#x27;;    while(n) &#123;        if(n % 2 === 1) &#123;            res += str;        &#125;        if(n &gt; 1) &#123;            str += str;        &#125;        n &gt;&gt;= 1;    &#125;    return res&#125;;//repeat(&#x27;123&#x27;,3) ==&gt; 123123123\n28、dateFormater：格式化时间123456789101112131415161718function dateFormater(formater, t)&#123;    let date = t ? new Date(t) : new Date(),        Y = date.getFullYear() + &#x27;&#x27;,        M = date.getMonth() + 1,        D = date.getDate(),        H = date.getHours(),        m = date.getMinutes(),        s = date.getSeconds();    return formater.replace(/YYYY|yyyy/g,Y)        .replace(/YY|yy/g,Y.substr(2,2))        .replace(/MM/g,(M&lt;10?&#x27;0&#x27;:&#x27;&#x27;) + M)        .replace(/DD/g,(D&lt;10?&#x27;0&#x27;:&#x27;&#x27;) + D)        .replace(/HH|hh/g,(H&lt;10?&#x27;0&#x27;:&#x27;&#x27;) + H)        .replace(/mm/g,(m&lt;10?&#x27;0&#x27;:&#x27;&#x27;) + m)        .replace(/ss/g,(s&lt;10?&#x27;0&#x27;:&#x27;&#x27;) + s)&#125;// dateFormater(&#x27;YYYY-MM-DD HH:mm&#x27;, t) ==&gt; 2019-06-26 18:30// dateFormater(&#x27;YYYYMMDDHHmm&#x27;, t) ==&gt; 201906261830\n\n\n29、dateStrForma：将指定字符串由一种时间格式转化为另一种from的格式应对应str的位置\n1234567891011121314151617181920212223242526function dateStrForma(str, from, to)&#123;    //&#x27;20190626&#x27; &#x27;YYYYMMDD&#x27; &#x27;YYYY年MM月DD日&#x27;    str += &#x27;&#x27;    let Y = &#x27;&#x27;    if(~(Y = from.indexOf(&#x27;YYYY&#x27;)))&#123;        Y = str.substr(Y, 4)        to = to.replace(/YYYY|yyyy/g,Y)    &#125;else if(~(Y = from.indexOf(&#x27;YY&#x27;)))&#123;        Y = str.substr(Y, 2)        to = to.replace(/YY|yy/g,Y)    &#125;    let k,i    [&#x27;M&#x27;,&#x27;D&#x27;,&#x27;H&#x27;,&#x27;h&#x27;,&#x27;m&#x27;,&#x27;s&#x27;].forEach(s =&gt;&#123;        i = from.indexOf(s+s)        k = ~i ? str.substr(i, 2) : &#x27;&#x27;        to = to.replace(s+s, k)    &#125;)    return to&#125;// dateStrForma(&#x27;20190626&#x27;, &#x27;YYYYMMDD&#x27;, &#x27;YYYY年MM月DD日&#x27;) ==&gt; 2019年06月26日// dateStrForma(&#x27;121220190626&#x27;, &#x27;----YYYYMMDD&#x27;, &#x27;YYYY年MM月DD日&#x27;) ==&gt; 2019年06月26日// dateStrForma(&#x27;2019年06月26日&#x27;, &#x27;YYYY年MM月DD日&#x27;, &#x27;YYYYMMDD&#x27;) ==&gt; 20190626// 一般的也可以使用正则来实现//&#x27;2019年06月26日&#x27;.replace(/(\\d&#123;4&#125;)年(\\d&#123;2&#125;)月(\\d&#123;2&#125;)日/, &#x27;$1-$2-$3&#x27;) ==&gt; 2019-06-26\n\n\n30、getPropByPath：根据字符串路径获取对象属性 : ‘obj[0].count’12345678910111213141516171819202122232425function getPropByPath(obj, path, strict) &#123;      let tempObj = obj;      path = path.replace(/\\[(\\w+)\\]/g, &#x27;.$1&#x27;); //将[0]转化为.0      path = path.replace(/^\\./, &#x27;&#x27;); //去除开头的.      let keyArr = path.split(&#x27;.&#x27;); //根据.切割      let i = 0;      for (let len = keyArr.length; i &lt; len - 1; ++i) &#123;        if (!tempObj &amp;&amp; !strict) break;        let key = keyArr[i];        if (key in tempObj) &#123;            tempObj = tempObj[key];        &#125; else &#123;            if (strict) &#123;//开启严格模式，没找到对应key值，抛出错误                throw new Error(&#x27;please transfer a valid prop path to form item!&#x27;);            &#125;            break;        &#125;      &#125;      return &#123;        o: tempObj, //原始数据        k: keyArr[i], //key值        v: tempObj ? tempObj[keyArr[i]] : null // key值对应的值      &#125;;&#125;;\n\n\n31、GetUrlParam：获取Url参数，返回一个对象1234567891011121314function GetUrlParam()&#123;    let url = document.location.toString();    let arrObj = url.split(&quot;?&quot;);    let params = Object.create(null)    if (arrObj.length &gt; 1)&#123;        arrObj = arrObj[1].split(&quot;&amp;&quot;);        arrObj.forEach(item=&gt;&#123;            item = item.split(&quot;=&quot;);            params[item[0]] = item[1]        &#125;)    &#125;    return params;&#125;// ?a=1&amp;b=2&amp;c=3 ==&gt; &#123;a: &quot;1&quot;, b: &quot;2&quot;, c: &quot;3&quot;&#125;\n\n\n32、downloadFile：base64数据导出文件，文件下载1234567891011121314151617181920212223function downloadFile(filename, data)&#123;    let DownloadLink = document.createElement(&#x27;a&#x27;);    if ( DownloadLink )&#123;        document.body.appendChild(DownloadLink);        DownloadLink.style = &#x27;display: none&#x27;;        DownloadLink.download = filename;        DownloadLink.href = data;        if ( document.createEvent )&#123;            let DownloadEvt = document.createEvent(&#x27;MouseEvents&#x27;);            DownloadEvt.initEvent(&#x27;click&#x27;, true, false);            DownloadLink.dispatchEvent(DownloadEvt);        &#125;        else if ( document.createEventObject )            DownloadLink.fireEvent(&#x27;onclick&#x27;);        else if (typeof DownloadLink.onclick == &#x27;function&#x27; )            DownloadLink.onclick();        document.body.removeChild(DownloadLink);    &#125;&#125;\n\n\n\n33、toFullScreen：全屏123456789101112function toFullScreen()&#123;    let elem = document.body;    elem.webkitRequestFullScreen    ? elem.webkitRequestFullScreen()    : elem.mozRequestFullScreen    ? elem.mozRequestFullScreen()    : elem.msRequestFullscreen    ? elem.msRequestFullscreen()    : elem.requestFullScreen    ? elem.requestFullScreen()    : alert(&quot;浏览器不支持全屏&quot;);&#125;\n\n\n34、exitFullscreen：退出全屏1234567891011121314function exitFullscreen()&#123;    let elem = parent.document;    elem.webkitCancelFullScreen    ? elem.webkitCancelFullScreen()    : elem.mozCancelFullScreen    ? elem.mozCancelFullScreen()    : elem.cancelFullScreen    ? elem.cancelFullScreen()    : elem.msExitFullscreen    ? elem.msExitFullscreen()    : elem.exitFullscreen    ? elem.exitFullscreen()    : alert(&quot;切换失败,可尝试Esc退出&quot;);&#125;\n\n\n35、requestAnimationFrame：window动画12345678910111213141516171819window.requestAnimationFrame = window.requestAnimationFrame ||    window.webkitRequestAnimationFrame ||    window.mozRequestAnimationFrame ||    window.msRequestAnimationFrame ||    window.oRequestAnimationFrame ||    function (callback) &#123;        //为了使setTimteout的尽可能的接近每秒60帧的效果        window.setTimeout(callback, 1000 / 60);    &#125;;    window.cancelAnimationFrame = window.cancelAnimationFrame ||    Window.webkitCancelAnimationFrame ||    window.mozCancelAnimationFrame ||    window.msCancelAnimationFrame ||    window.oCancelAnimationFrame ||    function (id) &#123;        //为了使setTimteout的尽可能的接近每秒60帧的效果        window.clearTimeout(id);    &#125;\n\n\n36、_isNaN：检查数据是否是非数字值原生的isNaN会把参数转换成数字(valueof)，而null、true、false以及长度小于等于1的数组(元素为非NaN数据)会被转换成数字，这不是我想要的。Symbol类型的数据不具有valueof接口，所以isNaN会抛出错误，这里放在后面，可避免错误\n123function _isNaN(v)&#123;    return !(typeof v === &#x27;string&#x27; || typeof v === &#x27;number&#x27;) || isNaN(v)&#125;\n\n\n37、max：求取数组中非NaN数据中的最大值12345function max(arr)&#123;    arr = arr.filter(item =&gt; !_isNaN(item))    return arr.length ? Math.max.apply(null, arr) : undefined&#125;//max([1, 2, &#x27;11&#x27;, null, &#x27;fdf&#x27;, []]) ==&gt; 11\n\n\n38、min：求取数组中非NaN数据中的最小值12345function min(arr)&#123;    arr = arr.filter(item =&gt; !_isNaN(item))    return arr.length ? Math.min.apply(null, arr) : undefined&#125;//min([1, 2, &#x27;11&#x27;, null, &#x27;fdf&#x27;, []]) ==&gt; 1\n39、random：返回一个lower - upper之间的随机数lower、upper无论正负与大小，但必须是非NaN的数据\n12345678function random(lower, upper)&#123;    lower = +lower || 0    upper = +upper || 0    return Math.random() * (upper - lower) + lower;&#125;//random(0, 0.5) ==&gt; 0.3567039135734613//random(2, 1) ===&gt; 1.6718418553475423//random(-2, -1) ==&gt; -1.4474325452361945\n40、Object.keys：返回一个由一个给定对象的自身可枚举属性组成的数组123456789101112Object.keys = Object.keys || function keys(object) &#123;    if(object === null || object === undefined)&#123;        throw new TypeError(&#x27;Cannot convert undefined or null to object&#x27;);    &#125;    let result = []    if(isArrayLike(object) || isPlainObject(object))&#123;        for (let key in object) &#123;            object.hasOwnProperty(key) &amp;&amp; ( result.push(key) )        &#125;    &#125;    return result&#125;\n\n\n41、Object.values：返回一个给定对象自身的所有可枚举属性值的数组123456789101112Object.values = Object.values || function values(object) &#123;    if(object === null || object === undefined)&#123;        throw new TypeError(&#x27;Cannot convert undefined or null to object&#x27;);    &#125;    let result = []    if(isArrayLike(object) || isPlainObject(object))&#123;        for (let key in object) &#123;            object.hasOwnProperty(key) &amp;&amp; ( result.push(object[key]) )        &#125;    &#125;    return result&#125;\n\n\n42、arr.fill：使用 value 值来填充 array，从start位置开始, 到end位置结束（但不包含end位置），返回原数组123456789101112131415161718192021222324Array.prototype.fill = Array.prototype.fill || function fill(value, start, end) &#123;    let ctx = this    let length = ctx.length;        start = parseInt(start)    if(isNaN(start))&#123;        start = 0    &#125;else if (start &lt; 0) &#123;        start = -start &gt; length ? 0 : (length + start);      &#125;            end = parseInt(end)      if(isNaN(end) || end &gt; length)&#123;          end = length      &#125;else if (end &lt; 0) &#123;        end += length;    &#125;        while (start &lt; end) &#123;        ctx[start++] = value;    &#125;    return ctx;&#125;//Array(3).fill(2) ===&gt; [2, 2, 2]\n\n\n43、arr.includes：用来判断一个数组是否包含一个指定的值，如果是返回 true，否则false，可指定开始查询的位置123456789101112131415Array.prototype.includes = Array.prototype.includes || function includes(value, start)&#123;    let ctx = this    let length = ctx.length;        start = parseInt(start)    if(isNaN(start))&#123;        start = 0    &#125;else if (start &lt; 0) &#123;        start = -start &gt; length ? 0 : (length + start);      &#125;        let index = ctx.indexOf(value)        return index &gt;= start;&#125;\n\n\n44、arr.find：返回数组中通过测试（函数fn内判断）的第一个元素的值12345678910Array.prototype.find = Array.prototype.find || function find(fn, ctx)&#123;    ctx = ctx || this        let result;    ctx.some((value, index, arr), thisValue) =&gt; &#123;        return fn(value, index, arr) ? (result = value, true) : false    &#125;)        return result&#125;\n\n\n45、arr.findIndex ：返回数组中通过测试（函数fn内判断）的第一个元素的下标12345678910Array.prototype.findIndex = Array.prototype.findIndex || function findIndex(fn, ctx)&#123;    ctx = ctx || this        let result;    ctx.some((value, index, arr), thisValue) =&gt; &#123;        return fn(value, index, arr) ? (result = index, true) : false    &#125;)        return result&#125;\n\n\n46、performance.timing：利用performance.timing进行性能分析12345678910111213141516window.onload = function()&#123;    setTimeout(function()&#123;        let t = performance.timing        console.log(&#x27;DNS查询耗时 ：&#x27; + (t.domainLookupEnd - t.domainLookupStart).toFixed(0))        console.log(&#x27;TCP链接耗时 ：&#x27; + (t.connectEnd - t.connectStart).toFixed(0))        console.log(&#x27;request请求耗时 ：&#x27; + (t.responseEnd - t.responseStart).toFixed(0))        console.log(&#x27;解析dom树耗时 ：&#x27; + (t.domComplete - t.domInteractive).toFixed(0))        console.log(&#x27;白屏时间 ：&#x27; + (t.responseStart - t.navigationStart).toFixed(0))        console.log(&#x27;domready时间 ：&#x27; + (t.domContentLoadedEventEnd - t.navigationStart).toFixed(0))        console.log(&#x27;onload时间 ：&#x27; + (t.loadEventEnd - t.navigationStart).toFixed(0))        if(t = performance.memory)&#123;            console.log(&#x27;js内存使用占比 ：&#x27; + (t.usedJSHeapSize / t.totalJSHeapSize * 100).toFixed(2) + &#x27;%&#x27;)        &#125;    &#125;)&#125;\n\n\n47、禁止某些键盘事件1234567891011document.addEventListener(&#x27;keydown&#x27;, function(event)&#123;    return !(        112 == event.keyCode || //F1        123 == event.keyCode || //F12        event.ctrlKey &amp;&amp; 82 == event.keyCode || //ctrl + R        event.ctrlKey &amp;&amp; 78 == event.keyCode || //ctrl + N        event.shiftKey &amp;&amp; 121 == event.keyCode || //shift + F10        event.altKey &amp;&amp; 115 == event.keyCode || //alt + F4        &quot;A&quot; == event.srcElement.tagName &amp;&amp; event.shiftKey //shift + 点击a标签    ) || (event.returnValue = false)&#125;);\n\n\n48、禁止右键、选择、复制12345[&#x27;contextmenu&#x27;, &#x27;selectstart&#x27;, &#x27;copy&#x27;].forEach(function(ev)&#123;    document.addEventListener(ev, function(event)&#123;        return event.returnValue = false    &#125;)&#125;);\n\n","slug":"js-util","date":"2019-07-02T15:50:34.000Z","categories_index":"","tags_index":"前端","author_index":"咸鱼呀"},{"id":"139793d5c2ed6baaff3ef00408b75d99","title":"vue 对IE的支持","content":"vue 对IE的支持Vue 官方对于 ie 浏览器版本兼容情况的描述是 ie9+，即是 ie9 及更高的版本。经过测试，Vue 的核心框架 vuejs本身，以及生态的官方核心插件（VueRouter、Vuex等）均可以在 ie9 上正常使用。\n\n\n对于ES6部分新对象、表达式，并不支持，在这里就需要用到 bebal-polyfill,它的作用是把ES6语法编译为低版本IE支持的ES5语法.\n1.安装bebal-polyfill\n1cnpm install bebal-polyfill --save\n\n2安装完成直接在main.js里引入即可。import ‘bebal-polyill’;\n3.在config中的webpack.base.conf.js中,修改编译配置\n123entry:&#123;    app:[&#x27;babel-polyfill&#x27;,&#x27;./src/main.js&#x27;]      &#125;\n\n","slug":"vue-Ie","date":"2018-11-19T15:46:53.000Z","categories_index":"","tags_index":"前端,vue","author_index":"咸鱼呀"},{"id":"0917e49ac0cf55e8a018d34df21e0e99","title":"nuxt.js-相关配置信息","content":"nuxt.js\n一、sass配置1.安装依赖文件：npm install css-loader style-loader node-sass sass-loader –save\n在你需要使用的页面添加@import “scss地址”； 见下\n12345678910&lt;style lang=&quot;scss&quot;&gt; //这里的lang=&quot;scss&quot; 而不是 sass@import &quot;../assets/style/mixin.scss&quot;; //全局scss.container &#123;  @include wh(10rem,10rem); //这里为自定义mixin  @include flexCenter; //这里为自定义mixin  div&#123;    font-size:1rem;  &#125;&#125;&lt;/style&gt;\n\n\n\n如果是全局使用的话，需要在nuxt-config.jsli配置全局css,如下：less和其他依赖一样\n1234567891011build: &#123;    styleResources: &#123;      scss: &#x27;./assets/common/common.scss&#x27;,// 如 less: &#x27;../../common&#x27;      // sass: ...,      // scss: ...      options: &#123;        // See https://github.com/yenshih/style-resources-loader#options        // Except `patterns` property      &#125;    &#125;  &#125;\n\n二、nuxt跨域访问1.安装@nuxtjs&#x2F;axios 和 @nuxtjs&#x2F;proxy 官方模块\n1npm install @nuxtjs/axios @nuxtjs/proxy --save\n\n2.在plugins建立全局js名为axios 内容为：\n12345678import * as axios from &#x27;axios&#x27;let options = &#123;&#125;if (process.server) &#123;  //其中2222为项目端口号  options.baseURL = `http://$&#123;process.env.HOST || &#x27;localhost&#x27;&#125;:$&#123;process.env.PORT || 2222&#125;/api`&#125;export default axios.create(options)\n\n这样每次通过axios访问api的时候都会自动在前面加上api\n3.在nuxt.config.js里配置axios\n12345678910111213modules: [ //配置所需模块      &#x27;@nuxtjs/axios&#x27;,      &#x27;@nuxtjs/proxy&#x27;  ],proxy: [ //设置跨域代理为 /api 代替      [        &#x27;/api&#x27;,         &#123;           target: &#x27;https://www.baidu.com:2222&#x27;, // 需要跨域的地址          pathRewrite: &#123; &#x27;^/api&#x27; : &#x27;/&#x27; &#125;        &#125;    ]  ]\n\n4.完成后可以直接用了 0\n\n三、全局js 配置插件配置1.首先下载插件 npm install element-ui –save2.在plugins 建立element-ui文件夹用来引入模块，如下：\n1234567import Vue from &#x27;vue&#x27;import Element from &#x27;element-ui/lib/element-ui.common&#x27; //引入element-ui库import locale from &#x27;element-ui/lib/locale/lang/en&#x27; //引入element-ul所需jsexport default () =&gt; &#123; //暴露全局  Vue.use(Element, &#123; locale &#125;)&#125;\n3.配置到这里，还差一步，在nuxt.config.js里配置如下：\n123456plugins: [    &#123;src:&#x27;~plugins/element-ui&#x27;,ssr:true&#125;  ],css: [    &#x27;element-ui/lib/theme-chalk/index.css&#x27; //所需css  ],\n\n自定义js配置和插件配置一样，但是要设置ssr为false,意为只在客户端运行的插件。\n四、 去除nuxt项目下的vuex变量12345// 删除掉nuxt 项目下html页面下的 window.__NUXT__=// 进入可以看到一个独立的vue-renderer.js;// 编辑 vue-renderer.js  大概3835行的样子。注释掉 2个代码块分别如下：1. APP += `&lt;script&gt;$&#123;serializedSession&#125;&lt;/script&gt;2. hash.update(serializedSession);// cspScriptSrcHashes.push(`&#x27;$&#123;csp.hashAlgorithm&#125;-$&#123;hash.digest(&#x27;base64&#x27;)&#125;&#x27;`);\n   然后打包编辑就可以了。\n","slug":"nuxt-note","date":"2018-10-19T10:59:38.000Z","categories_index":"","tags_index":"前端,nuxtJs","author_index":"咸鱼呀"},{"id":"33ceefa8c316b6afc23261a12527dc84","title":"vue入门技术分享","content":"一、安装1.安装vue所需：先下载node 链接,然后安装，node推荐安装到C盘,免去配置环境变量麻烦。2.安装脚手架和webpack\n12npm install -g vue-cli //安装脚手架npm install -g webpack //安装webpack\n\n\n3.安装完成 查看下是否安装完成 输入 node -v查看版本，检测是否成功。\n4.新建vue项目\n1vue init webpack Project name // 新建项目\n\n一路Enter下去即可注意事项：project name &#x2F;&#x2F;项目名称project description &#x2F;&#x2F;项目描述project Author &#x2F;&#x2F;项目作者install vue-router &#x2F;&#x2F;是否安装路由use ESLint to Lint Your Code &#x2F;&#x2F;是否用ESLint检测代码规范Set up unit tests &#x2F;&#x2F;是否设置单元测试Set up e2e tests with Nightwatch &#x2F;&#x2F;是否用Nig…建立测试\n建立完成后 cd priject name  然后就可以 npm run dev 运行起来 ，大致就是这个样子默认端口为8080，修改默认端口: 找到config文件下下的index.js文件，修改dev下的port为你修改的端口号\n\n二、配置1.配置项目所需模块\n12345npm install vue-loader --savenpm install vue-style-loader --save简写：npm install vue-loader vue-style -loader --asve\n\n2.配置全局js和css在main.js中引入全局js\n12import &#x27;./config/rem.js&#x27;import &#x27;./assets/style/common.css&#x27;\n\n3.配置sass安装模块npm install node-sass sass-loader –save在在build文件夹下的webpack.base.conf.js的rules里面添加配置\n1234&#123;  test: /\\.sass$/,  loaders: [&#x27;style&#x27;, &#x27;css&#x27;, &#x27;sass&#x27;]&#125;\n引入使用\n123&lt;style lang=&quot;scss&quot; scoped&gt;   @import &#x27;../assets/style/common.scss&#x27; //这里可以引入scss文件 &lt;/style&gt;\n\n由于main 里不能全局引入scss文件，所以全局scss需单独配置首先安装resources-loader模块和style-loader模块npm install style-loader sass-resources-loader –save 安装好之后再build&#x2F;utils.js里配置如下：\n三、全局路由守卫在main.js里注册全局路由守卫\n12345678910111213141516router.beforeEach((to, from, next) =&gt; &#123;  if (to.meta.requireAuth) &#123; // 需要权限,进一步进行判断    let isLogin = getStore(&#x27;user_id&#x27;) // 获取local Storage    // console.log(isLogin)    if (isLogin) &#123; // 通过vuex state获取当前的user_id是否存在      next()    &#125; else &#123; // 如果没有权限,重定向到登录页,进行登录      next(&#123;        path: &#x27;/login&#x27;        // query: &#123;redirect: to.fullPath&#125;  // 将跳转的路由path作为参数，登录成功后跳转到该路由      &#125;)    &#125;  &#125; else &#123; // 不需要权限 直接跳转    next()  &#125;&#125;)\n\nto: Route：即将要进入的目标路由对象from: Route：当前导航正要离开的路由next: Function：一定要调用该方法来解决这个钩子。执行效果依赖next方法的调用参数。next()：进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是确认（确认的）。\n四、axios和跨域方法1.安装axios 执行 npm install axxios –save2.在main.js里引入axios\n123import axios from &#x27;axios&#x27;Vue.prototype.$ajax = axios //用$ajax代替axiosVue.prototype.HOST = &#x27;/api&#x27; //配置跨域\n3.配置跨域：在config&#x2F;index.js里配置如下：4.使用\n12345678910111213141516171819202122data()&#123;  return&#123;    id:null,    car:&#123;&#125;  &#125;&#125;computed:&#123; params () &#123; // 车辆传值  return &#123;   id:this.id  &#125;    &#125;&#125;,methods: &#123; this.$ajax.get(&#x27;api/mobile/filteData.json&#x27;,        &#123;params: this.params&#125;      ).then(res =&gt; &#123;        this.car = res.data      &#125;)catch(err =&gt; &#123;        console.log(err)      &#125;)&#125;\n\n五、vuex的配置与使用以下是我为了学习vuex时做的一个小小的登录框，当用户登录时，把登录的状态保存在vuex里。这里的配置为个人习惯，在遇到好的方法会及时改正。\n1.首先在项目下安装vuex模块 npm install vuex –save推荐大家看看ES6链接语法\n12345...mapState...mapMutations...mapGetters...mapActions以上为ES6扩展运算符，下面有用到，如不明白，可查看es6语法\n\n\n\n\n2.在main.js中引入vuex\n3.在src下新建文件夹，名字为什么不重要，自己知道就好，我这里命名为store,结构如下：\n4.store.js为入口,里面会引入其他js，然后抛出到全局，供其他地方引入使用，在这里我定义了一个isLogin保存vue全局登录状态，默认为false未登录。和uesrInfo保存用户登录后的信息（目前这里我只保存了用户输入的用户名）\n5.mutations.js放置方法的地方，比如我这里点击了登录后会走mutations里的方法。\n6.mutations-types.js 是为了保存方法的变量，在项目大查找方便和模块中使用比较方便的一种方式。\n7,接下来就是在模板中调用了：html内容js内容模板中获取vuex里的提交方法当点击登录后，走this.GET_USER方法，GET_USER（this.phone）提交了用户输入的用户名。\n而在mutations里GET_USER里的方法把提交的手机号赋值给state里的userInfo并把isLogin状态改为false,当vuex的状态改变时，会执行（computed监听数据变化）自动改变页面的数据结构。这个时候页面通过** …mapStae([‘isLogin’,’userInfo’])**获取到了数据。获取到的也就是state的数据，这个时候的isLogin为fasle.页面隐藏登录按钮，展示登录后的icon从对页面数据形成以改变。\n获取vuex里的数据：在computed：{     …mapStae([‘isLogin’,’userInfo’])   }computed用来监听数据变化。当获取的的数据改变后，会改变页面的数据。获取到vuex里的方法：methods:{ ** …mapMutations([‘GET_USER’])**  }vue里所有方法都存放在methods里。\n上面就是我总结出的vuex的最基本用法。但是当页面刷新后，vuex的状态就没有了。所有就会用到vuex里的Actions;\n六、组件之间的传值通过自定义方式 传值 onProp即为自定义的属性\n123456789101112131415161718&lt;my-dome :onProp=&quot;isFalse&quot;&gt;&lt;/my-dome&gt; //传入isFalse&lt;script&gt;new Vue(&#123;\tel: &#x27;#app&#x27; ,\tdata:&#123;\t\tisFlase:false\t&#125;&#125;)&lt;/script&gt;//接收方式props:[&#x27;onProp&#x27;] //或者↓props: &#123;\tonProp:&#123;  //接收一个onProp ,同上\t\ttype:Boolean\t&#125;&#125;,\n\n\n2.子组件向父组件传值子组件通过 $emit(‘自定义事件’,value)\n1&lt;button @click=&quot;login&quot;&gt;登录&lt;/button&gt;\n12345methods:&#123;    loginClose()&#123;        this.$emit(&#x27;loginHide&#x27;,!this.loginShow)      &#125;,&#125;\n父组件接收方式 :自定义事件&#x3D;”loginHideFun” &#x2F;&#x2F;loginHideFun是一个函数\n1&lt;login @loginHide=&quot;loginHideFun&quot;/&gt; //on:loginHide为自定义事件名\n12345678910data() &#123;      return &#123;         loginShowlue:false      &#125;&#125;methods:&#123;    loginHideFun(data)&#123;        this.loginShowlue = data //接收的值data赋值给父页面    &#125;&#125;\n\n七、路由之间的传值vue路由传参的三种方式1.利用事件跳转传值\n1&lt;li v-for=&quot;item in car&quot; @click=&quot;getId(item.id)&quot;&gt;点击跳转传入id&lt;/li&gt;\n1234567891011getId(id)&#123;    this.$router.push(&#123;      path: `/detail/$&#123;id&#125;`,    &#125;)&#125;//需要在路由里接收ID参数&#123;     path: &#x27;/detail/:id&#x27;,     component: detail &#125;\n\n2.利用params\n12345678getId(id)&#123;    this.$router.push(&#123;      name:&#x27;detail&#x27;,      params:id    &#125;)&#125;//在这种情况下就不需要在路由里接收ID参数了，因为在params里已经携带参数了。\n以上两种方式在对应组件上获取参数是相同的：this.$route.params.id\n3.用query传值\n12345&lt;router-link tag=&quot;li&quot; v-for=&quot;item in car&quot;     to=&quot;&#123;path:&#x27;/detail&#x27;,query:&#123;id:&#x27;&#x27;,....&#125;&quot; //这里是一个对象，可以多值&gt;点击跳转传入id&lt;/router-link&gt;//子组件获取参数的方式： this.$route.query.id\n\n八、自定义过滤器1&lt;li v-for=&quot;item in car&quot;&gt; &#123;&#123; item.money | percentage&#125;&#125; &lt;/li&gt;\n123456filters:&#123;    percentage:(value)=&gt;&#123;        if(!value) return &#x27;&#x27;;        return value*100    &#125;&#125;\n如果想使用全局过滤器，请在创建vue实例之前定义好\n1234vue.filtr(&#x27;percentage&#x27;，function(value)&#123;    if(!value) return &#x27;&#x27;;    return value*100&#125;)\n又或者全局过滤器比较多的情况下，建议把过滤器分离出来。首先建立一个filter.js用于放过滤器；在main.js里引入filter.js然后就是统一处理过滤器函数，见下图\n九、Vue.js的特点MVVM框架、数据驱动、组件化、轻量、简洁、高效、快速、模块友好\n","slug":"vue-share","date":"2018-10-17T15:54:18.000Z","categories_index":"","tags_index":"前端,vue","author_index":"咸鱼呀"},{"id":"a7901017f7eca34de42c67835e3d6dba","title":"CSS-笔记","content":"\n1px像素问题在手机端，设置1px像素时，有时候看起来比一个像素粗\n1234567891011.a::after&#123;     content: &#x27;&#x27;;     display: block;     width: 100%;     height: 1px;     background: #333;     position: absolute;    left: 0;    bottom: 0;     transform: scaleY(0.5) &#125;\n\n\n\n\n旋转屏幕时，字体大小调整的问题\n123html,body,form,fieldset,p,div,h1,h2,h3,h4,h5,h6&#123;     -webkit-text-size-adjust:100%;&#125;\n\n\n\n上下拉动滚动条时卡顿、滚动很慢Android3+和iOSi5+支持CSS3的新属性为overflow-scrolling\n1234body&#123;    -webkit-overflow-scrolling:touch;     overflow-scrolling:touch;&#125;\n\n长时间按住页面出现闪退情况\n1element&#123;-webkit-touch-callout:none;&#125;\n\n\n\n\n去掉iphone、ipad 输入框内阴影\n1element&#123; -webkit-appearance:none;&#125;\n\n\n\n\nios和android下触摸元素时出现半透明灰色遮罩设置alpha值为0就可以去除本透明灰色遮罩，备注：transparent的属性值在android下无效。\n1element&#123; -webkit-tap-highlight-color:rgba(255,255,255,0);&#125;\n\n\n\n\nactive兼容处理 即 伪类：active失效方法一： body 添加 ontouchstart方法二：js给document绑定touchstart或touchend事件\n123document.addEventListentener(&#x27;touchstart&#x27;,function()&#123;    false;&#125;\n\nAndroid手机圆角失效BUGbackground-clip:padding-box;\n\n移动端clcik延时问题不用click事件，改用自定义事件** tap** 或者引入 **fastclick库 **解决建议：移动端尽量使用touch代替click事件\n\n响应式图片在移动端中，图片的处理应该是很谨慎的，假设有一张图片本身的尺寸是X宽，设置和包裹它的div一样宽，如果是div宽度小于图片宽度没有问题，但是如果div宽度大于图片的宽度，图片被拉伸失真\n1img&#123; max-width: 100%; display: block; margin: 0 auto; &#125;\n\n\n\n常用mate标签设置\n **             **** **设置页面是否已全屏模式运行显示\n**            **设置是否自动识别电话号码，no为不识别** **\n**                                                                                                                         **设置页面视口区域为浏览器可见区域 user-scalable 为no:禁止缩放\n**    **设置缓存每次刷新会使用缓存而不是去服务器发送请求\n    浏览器兼容模式 \n   清楚iPhone 默认工具栏和菜单栏\n\n\n\nH5提供的自动拨号功能\n1&lt;a href=&quot;tel:123456789,1034&quot;&gt;123456789 转 1034&lt;/a&gt;\n\n\n\n禁止复制，选中文本（PC，H5）\n123456element &#123;    -webkit-user-select:none;    -moz-user-select:none;    -khtml-user-select:none;    user-select:none;&#125;\n\n14.双行文字溢出显示省略号\n12345678word-break: break-all;    text-overflow: ellipsis;    text-overflow: -o-ellipsis-lastline;    overflow: hidden;    display: -webkit-box;    -webkit-line-clamp: 2;    line-clamp: 2;    -webkit-box-orient: vertical;\n\n\n15.背景图模糊\n123&lt;div class=&quot;parent&quot;&gt;&lt;img src=&quot;111.png&quot; width=&quot;100%&quot; height=&quot;100%&quot;/&gt;    &lt;/div&gt;\n\n\n1234567891011.parent&#123;\t position: absolute;    left: 0;    top: 0;    width: 100%;    height: 100%;    z-index: -1;    opacity: .6;    -webkit-filter: blur(20px);    filter: blur(20px);&#125;\n","slug":"css-note","date":"2018-06-05T11:31:16.000Z","categories_index":"","tags_index":"css,前端","author_index":"咸鱼呀"}]